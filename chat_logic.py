import os, re, random
from flask import current_app
from openai import OpenAI
from datetime import datetime
from app import db, ChatLog   # âœ… ë¶„ì„ ê·¸ë˜í”„ì— ë°˜ì˜í•˜ë ¤ë©´ DB ì ‘ê·¼ í•„ìš”

# === ê°ì • + ì¼ìƒ ì¹´í…Œê³ ë¦¬ ===
daily_categories = {
    "ë¬´ë§¥ë½ ì• ë§¤í•œ ê²ƒë“¤": [
        "ì—ë°”ì•¼", "ì• ë§¤í•˜ê¸´ í•´", "ê°€ë©´ ê°€", "í•˜ë©´ í•´", "ã„±ã„±", "ê°€ë³´ìê³ ",
        "ì–´ì©Œê² ì–´", "í•´ì•¼ì§€ ë­", "ì•„ í•˜ê¸° ì‹«ìŒ", "ì•„ë‹ˆ ê·¼ë° ì§„ì§œ", "ã„¹ã…‡", "ì§„ì‹¬", "í—", "ëŒ€ë°•",
        "ê²ë‚˜", "ê°œ ", "ã…ˆã„´", "ã„±ã…‡ã…‡", "ã„±ã…‡ã„±", "ë¯¸ì³¤ë‹¤", "ì™€", "ê·¸ë‹ˆê¹Œ", "ìŒ", "ã… ã… "
    ],
    "ì¸ì‚¬/ìê¸°ì†Œê°œ": ["ì•ˆë…•", "í•˜ì´", "ë°˜ê°€ì›Œ", "í—¬ë¡œ", "ëˆ„êµ¬", "ë„ˆ ë­ì•¼", "ì´ë¦„", "ì†Œê°œ"],
    "ê°ì‚¬/ì¹­ì°¬": ["ê³ ë§ˆì›Œ", "ê°ì‚¬", "ë•ë¶„", "ì‚¬ë‘í•´", "ì¢‹ì•„í•´", "ëŒ€ë‹¨í•´", "ë©‹ì§€ë‹¤", "êµ¿", "ì˜í–ˆì–´"],
    "ë†€ëŒ/ê°íƒ„": ["í—", "ì„¸ìƒì—", "ì§„ì§œ?", "ìš°ì™€", "ëŒ€ë°•", "ì†Œë¦„", "í—‰"],
    "ìš•ì„¤/ë¶€ì •": ["ì§œì¦", "í™”ë‚˜", "ë¹¡ì³", "ì‹«ì–´", "ìš°ìš¸", "í˜ë“¤", "ë¶ˆì•ˆ", "ê±±ì •", "ì§€ì³¤"],
    "ë°¥/ìŒì‹": ["ë°¥", "ì‹ì‚¬", "ë¼ë©´", "ì¹˜í‚¨", "í”¼ì", "ì•¼ì‹", "ê³¼ì", "ë–¡ë³¶ì´"],
    "ìŒë£Œ/ë””ì €íŠ¸": ["ì»¤í”¼", "ì°¨", "ë²„ë¸”í‹°", "ì½œë¼", "ì‚¬ì´ë‹¤", "ë””ì €íŠ¸", "ì•„ì´ìŠ¤í¬ë¦¼"],
    "ë‚ ì”¨/ê³„ì ˆ": ["ë‚ ì”¨", "ë¹„", "ëˆˆ", "ë”ì›Œ", "ì¶¥", "ê°€ì„", "ì—¬ë¦„", "ê²¨ìš¸", "ë´„"],
    "ê³µë¶€/í•™êµ": ["ê³µë¶€", "í•™êµ", "ì‹œí—˜", "ì„±ì ", "ê³¼ì œ", "ìˆ˜ì—…", "êµìˆ˜ë‹˜"],
    "ê´€ê³„/ì¹œêµ¬": ["ì¹œêµ¬", "ê°€ì¡±", "ì—°ì• ", "ì‚¬ëŒ", "ê´€ê³„"]
}

daily_responses = {
    "ë¬´ë§¥ë½ ì• ë§¤í•œ ê²ƒë“¤": ["ìŒâ€¦ ê·¸ë ‡êµ¬ë‚˜.", "ê·¸ëŸ´ ìˆ˜ë„ ìˆì§€.", "ã…ã… ì•Œê² ì–´.", "ì‚¬ëŒë§ˆë‹¤ ë‹¤ë¥´ë”ë¼."],
    "ì¸ì‚¬/ìê¸°ì†Œê°œ": ["ì•ˆë…•! ë§Œë‚˜ì„œ ë°˜ê°€ì›Œ ğŸ˜Š", "í•˜ì´~ ì˜¤ëŠ˜ ê¸°ë¶„ ì–´ë•Œ?", "ë‚œ ë¼ë¦¬ì•¼ ğŸ¤– ë„¤ ì–˜ê¸° ë“¤ì–´ì£¼ëŠ” ì¹œêµ¬!"],
    "ê°ì‚¬/ì¹­ì°¬": ["ë‚˜ë„ ê³ ë§ˆì›Œ ğŸ™", "ê·¸ë ‡ê²Œ ë§í•´ì£¼ë‹ˆê¹Œ ê¸°ë¶„ ì¢‹ë‹¤ ğŸ˜€", "ë„ˆ ì§„ì§œ ì°©í•˜ë„¤!"],
    "ë†€ëŒ/ê°íƒ„": ["í— ëŒ€ë°•â€¦", "ì§„ì§œ?", "ì™€â€¦ ì‹ ê¸°í•˜ë‹¤!", "ìš°ì™€~ ë©‹ì§€ë‹¤!"],
    "ìš•ì„¤/ë¶€ì •": ["ë§ì´ í˜ë“ ê°€ ë´ ğŸ˜¢", "ì†ìƒí–ˆê² ë‹¤.", "ê´œì°®ì•„, ì²œì²œíˆ ì–˜ê¸°í•´ë„ ë¼."],
    "ë°¥/ìŒì‹": ["ë°¥ì€ ë¨¹ì—ˆì–´?", "ìš”ì¦˜ ìì£¼ ë¨¹ëŠ” ìŒì‹ ìˆì–´?", "ì•¼ì‹ ìì£¼ ë¨¹ì–´?", "ì¹˜í‚¨ì€ ì–¸ì œ ë¨¹ì–´ë„ ì˜³ì§€ ğŸ—"],
    "ìŒë£Œ/ë””ì €íŠ¸": ["ì»¤í”¼ ìì£¼ ë§ˆì…”?", "ë‹¨ ê±° ì¢‹ì•„í•´? ğŸ«", "ë²„ë¸”í‹° ì¢‹ì•„í•´?"],
    "ë‚ ì”¨/ê³„ì ˆ": ["ì˜¤ëŠ˜ ë‚ ì”¨ ì–´ë• ì–´?", "ë¹„ ì˜¤ëŠ” ë‚  ê¸°ë¶„ ë‹¬ë¼ì ¸?", "ìš”ì¦˜ ìŒ€ìŒ€í•˜ì§€ ì•Šì•„?"],
    "ê³µë¶€/í•™êµ": ["ê³µë¶€í•˜ëŠë¼ í˜ë“¤ì§€?", "ì‹œí—˜ ê¸°ê°„ì´ë¼ ë°”ì˜ê² ë„¤.", "ìš”ì¦˜ ìˆ˜ì—… ì¬ë°Œì–´?"],
    "ê´€ê³„/ì¹œêµ¬": ["ìµœê·¼ì— ì¹œêµ¬ë“¤ì´ë‘ ì¬ë°ŒëŠ” ì¼ ìˆì—ˆì–´?", "ê°€ì¡±ë“¤ì´ë‘ ì˜ ì§€ë‚´?", "ìš”ì¦˜ ì™¸ë¡­ì§„ ì•Šì•„?"]
}

default_responses = ["ìŒâ€¦ ì˜ ëª¨ë¥´ê² ì–´.", "ê·¸ë ‡êµ¬ë‚˜~ ì¢€ ë” ì–˜ê¸°í•´ì¤„ë˜?", "í¥ë¯¸ë¡­ë„¤.", "ì¬ë°ŒëŠ” ì–˜ê¸°ì•¼!"]

# === ìì—°ìŠ¤ëŸ¬ìš´ PHQ-A ë¦¬ë”© ëª¨ë“ˆ ===
phq_questions = [
    "ìš”ì¦˜ì€ ì˜ìš•ì´ ì¢€ ë–¨ì–´ì§„ ëŠë‚Œì´ì•¼?",
    "ì ì€ ì˜ ì? ì•„ë‹ˆë©´ ë’¤ì²™ì´ê±°ë‚˜ ìì£¼ ê¹¨?",
    "ìš”ì¦˜ ì…ë§›ì€ ì–´ë•Œ? ì „ì´ë‘ ì¢€ ë‹¬ë¼?",
    "ì§‘ì¤‘ì´ ì˜ ì•ˆ ë˜ê±°ë‚˜, ìˆ˜ì—… ë•Œ ë©í•  ë•Œ ìˆì–´?",
    "ê°€ë”ì€ ìŠ¤ìŠ¤ë¡œê°€ ì“¸ëª¨ì—†ë‹¤ê³  ëŠê»´ì§ˆ ë•Œ ìˆì–´?",
    "ìš”ì¦˜ í”¼ê³¤í•˜ê±°ë‚˜ ê¸°ìš´ ë¹ ì§ˆ ë•Œê°€ ë§ì•„?",
    "ì•„ë¬´ê²ƒë„ í•˜ê¸° ì‹«ì„ ë•Œ ìˆì§€?",
    "ì‚¬ëŒ ë§Œë‚˜ëŠ” ê²Œ ê·€ì°®ê±°ë‚˜ í”¼í•˜ê³  ì‹¶ì„ ë•Œ ìˆì–´?",
    "í˜¹ì‹œ ì£½ê³  ì‹¶ê±°ë‚˜ ì‚¬ë¼ì§€ê³  ì‹¶ë‹¤ëŠ” ìƒê°ì´ ë“  ì  ìˆì–´?"
]
phq_context = {}  # {user_id: {"index": int, "score": int, "cool": int}}

def classify_phq_response(text: str) -> int:
    text = text.lower()
    if re.search(r"(ì „í˜€|ì—†|ê´œì°®|ì•ˆ ê·¸ë˜|ë³„ë¡œ ì•„ë‹˜|ê±°ì˜ ì—†|ë“œë¬¼|ì˜ ì•ˆ)", text): return 0
    if re.search(r"(ê°€ë”|ë©°ì¹ |ì¡°ê¸ˆ|ì•½ê°„|ë•Œë•Œë¡œ|ê°„í˜¹)", text): return 1
    if re.search(r"(ìì£¼|ì¢…ì¢…|ì ˆë°˜|ë§ì´|ê½¤|ì¢…ì¼|í•˜ë£¨ì˜ ì ˆë°˜)", text): return 2
    if re.search(r"(ë§¤ì¼|ë§¨ë‚ |í•­ìƒ|ëŠ˜|ë§¤ë²ˆ|í•˜ë£¨ì¢…ì¼|ê³„ì†|ë§¤ ìˆœê°„)", text): return 3
    return 1

def interpret_phq_level(score: int):
    if score < 5: return "ì •ìƒ ğŸ˜Š", "ìš”ì¦˜ ë§ˆìŒì´ ê½¤ ì•ˆì •ì ì¸ ì‹œê¸°ì•¼."
    elif score < 10: return "ê°€ë²¼ìš´ ìš°ìš¸ ğŸ˜", "ì¡°ê¸ˆ ì§€ì³ ìˆëŠ” ë“¯í•´. ì ê¹ ì‰¬ì–´ê°€ë„ ì¢‹ì•„ â˜•"
    elif score < 15: return "ì¤‘ë“±ë„ ìš°ìš¸ ğŸ˜”", "ë§ˆìŒì´ ë¬´ê²ê²Œ ëŠê»´ì ¸. ê°€ê¹Œìš´ ì‚¬ëŒì—ê²Œ í„¸ì–´ë†”ë´."
    else: return "ì‹¬í•œ ìš°ìš¸ ğŸ˜¢", "ë§ì´ í˜ë“¤ì–´ ë³´ì—¬. í˜¼ì ë²„í‹°ì§€ ë§ê³  ê¼­ ì£¼ë³€ ë„ì›€ì„ ë°›ì•„ë´."

def update_phq(user_input, user_id):
    """ë‹µë³€ì„ ì ìˆ˜í™”í•˜ê³  DBì—ë„ ê¸°ë¡"""
    if user_id not in phq_context: return
    ctx = phq_context[user_id]
    if 0 < ctx["index"] <= len(phq_questions):
        score = classify_phq_response(user_input)
        ctx["score"] += score
        phq_context[user_id] = ctx
        # DBì— ê°ì • ê¸°ë¡ ì¶”ê°€ â†’ analyze ê·¸ë˜í”„ ë°˜ì˜
        with current_app.app_context():
            db.session.add(ChatLog(user_id=user_id, role="system",
                                   message=f"[PHQ] {phq_questions[ctx['index']-1]} â†’ {score}ì "))
            db.session.commit()

def maybe_ask_phq(user_input, user_id):
    """ëŒ€í™” ì¤‘ ìì—°ìŠ¤ëŸ½ê²Œ PHQ ì§ˆë¬¸ì„ ë˜ì§"""
    cues = ["í˜ë“¤", "ì§€ì³", "ê·€ì°®", "ì§œì¦", "ë¶ˆì•ˆ", "í”¼ê³¤", "ìš°ìš¸", "ê³µë¶€", "ì ", "ì‹ìš•", "ì˜ìš•", "ë¬´ê¸°ë ¥"]
    ctx = phq_context.get(user_id, {"index": 0, "score": 0, "cool": 0})

    # ì—°ì† ì§ˆë¬¸ ë°©ì§€ ì¿¨íƒ€ì„
    if ctx["cool"] > 0:
        ctx["cool"] -= 1
        phq_context[user_id] = ctx
        return None

    # ì‚¬ìš©ìê°€ ê°ì • ë‹¨ì„œë¥¼ ë§í–ˆì„ ë•Œ ë‹¤ìŒ ë¬¸í•­
    if any(c in user_input for c in cues):
        if ctx["index"] < len(phq_questions):
            q = phq_questions[ctx["index"]]
            ctx["index"] += 1
            ctx["cool"] = 3
            phq_context[user_id] = ctx
            prefix = random.choice([
                "ê·¸ëŸ° ë§ ë“¤ìœ¼ë‹ˆê¹Œ ì¢€ ê±±ì •ë¼.",
                "ìŒâ€¦ ìš”ì¦˜ ë„¤ ìƒíƒœê°€ ì‚´ì§ ê±±ì •ë¼ì„œ ê·¸ëŸ°ë°,",
                "í˜¹ì‹œ ê¶ê¸ˆí•´ì„œ ë¬»ëŠ”ë°,"
            ])
            return f"{prefix} {q}"

    # 9ë¬¸í•­ ì™„ë£Œ ì‹œ ê²°ê³¼ ëŒ€í™”
    if ctx["index"] >= len(phq_questions):
        level, msg = interpret_phq_level(ctx["score"])
        phq_context[user_id] = {"index": 0, "score": 0, "cool": 0}
        return f"ì§€ê¸ˆê¹Œì§€ ì–˜ê¸° ë“¤ì–´ë³´ë‹ˆê¹Œ {level} ìˆ˜ì¤€ì¸ ê²ƒ ê°™ì•„.\n{msg}"

    return None

# === ê¸°ë³¸ ê°ì •/ì¼ìƒ ë¡œì§ + GPT ë°±ì—… ===
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def classify_and_respond(user_input, user_id=None):
    """ì‚¬ìš©ì ì…ë ¥ â†’ ìì—° ë¦¬ë”© + ê·œì¹™í˜• + GPT ë°±ì—…"""
    text = user_input.strip()

    # ğŸ”¹ PHQ ì§„í–‰/ì—…ë°ì´íŠ¸
    update_phq(text, user_id)
    natural_q = maybe_ask_phq(text, user_id)
    if natural_q:
        return natural_q

    # ğŸ”¹ ê°ì • ê´€ë ¨
    for category, kws in daily_categories.items():
        if any(k in text for k in kws):
            return random.choice(daily_responses.get(category, default_responses))

    # ğŸ”¹ GPT ë°±ì—…
    try:
        completion = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content":
                 "ë„ˆëŠ” 'ë¼ë¦¬'ë¼ëŠ” ì´ë¦„ì˜ ë‹¤ì •í•˜ê³  ê³µê° ì˜í•˜ëŠ” ì¹œêµ¬ì•¼. "
                 "ëŒ€í™”ëŠ” ìì—°ìŠ¤ëŸ½ê³  ë”°ëœ»í•˜ê²Œ ì´ì–´ê°€. "
                 "ì‚¬ìš©ìì˜ ê°ì •ì„ ì´í•´í•˜ê³ , ê³µê° ì–´ë¦° ë§íˆ¬ë¡œ ëŒ€ë‹µí•´."},
                {"role": "user", "content": text}
            ]
        )
        return completion.choices[0].message.content.strip()

    except Exception as e:
        return f"âš ï¸ AI ì‘ë‹µ ì˜¤ë¥˜: {str(e)}"
